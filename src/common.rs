use core::hash::Hash;
use rand_core::{CryptoRng, RngCore};

#[cfg(not(feature = "std"))]
use alloc::{fmt::{self, Debug}, string::String, vec::Vec};
#[cfg(not(feature = "std"))]
use core::error::Error;
#[cfg(feature = "std")]
use std::{error::Error, fmt::{self, Debug}, string::String, vec::Vec};


#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};


/// Upper limit on the receive chain ratchet steps when trying to decrypt. Prevents a
/// denial-of-service attack where the attacker attempts to drive up the number of
/// message keys that must be stored tied to a single public key
pub const DEFAULT_MAX_SKIP: usize = 1000;

/// Maximum amount of skipped message keys that can be stored per double ratchet id.
/// The id represents a 1:1 (alice to bob, where same alice to different bob would
/// be a different id.) Prevents a denial-of-service attack where the attacker 
/// attempts drive up the number of message keys that must be stored by rotating 
/// public keys. Thus the key cache would store a maximum number of entries per 
/// across multiple chains.
pub const DEFAULT_MKS_CAPACITY: usize = 3000;

/// Message Counter (as seen in the header)
pub type Counter = u64;


/// `SessionState` requires the serde feature enablement
/// it allows for persistence (save/recover) of a double ratchet
/// state. It does not backup the Message Key Skip Store!
#[cfg(feature = "serde")]
#[derive(Serialize, Deserialize)]
pub struct SessionState {
    /// double ratchet pair id
    pub id: u64,
    // sending keypair (priv)
    pub(crate) dhs_priv: Vec<u8>,
    // sending keypair (pub)
    pub(crate) dhs_pub: Vec<u8>,
    /// receiving public key
    pub(crate) dhr: Option<Vec<u8>>,
    /// root key
    pub(crate) rk: Vec<u8>,
    /// chain key sending
    pub(crate) cks: Option<Vec<u8>>,
    /// chain key receiving
    pub(crate) ckr: Option<Vec<u8>>,
    /// sending message number
    pub(crate) ns: Counter,
    /// receiving message number
    pub(crate) nr: Counter,
    /// previous message number
    pub(crate) pn: Counter,
}

impl SessionState {
    /// encodes the session state to a json string
    ///
    /// # Errors
    /// `serde_json::Error`
    pub fn encode(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string(self)
    }
    /// decodes a session state from a json &str
    ///
    /// # Errors
    /// `serde_json::Error`
    pub fn decode(s: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(s)
    }
}

/// The Header that should be sent alongside the ciphertext.
///
/// The Header contains the information for the `DoubleRatchet` to find the correct `MessageKey` to
/// decrypt the message. It is generated by `ratchet_encrypt`
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Header<PublicKey> {
    /// The public half of the key-pair of the sender
    pub dh: PublicKey,

    /// Counts the number of messages that have been sent in the current symmetric ratchet
    pub n: Counter,

    /// Counts the number of messages that have been sent in the previous symmetric ratchet
    pub pn: Counter,
}

impl<PK: AsRef<[u8]>> Header<PK> {
    ///
    pub fn extend_bytes_into(&self, v: &mut Vec<u8>) {
        v.extend_from_slice(self.dh.as_ref());
        v.extend_from_slice(&self.pn.to_be_bytes());
        v.extend_from_slice(&self.n.to_be_bytes());
    }

    ///
    pub fn as_ref(&self) -> Vec<u8> {
        let mut bytes: Vec<u8> = Vec::new();
        bytes.extend_from_slice(self.dh.as_ref());
        bytes.extend_from_slice(&self.pn.to_be_bytes());
        bytes.extend_from_slice(&self.n.to_be_bytes());
        bytes
    }
}

/// Provider of the required cryptographic types and functions.
///
/// The implementer of this trait provides the `DoubleRatchet` with the required external functions
/// as given in the [specification].
///
/// # Security considerations
///
/// The details of the `CryptoProvider` are critical for providing security of the communication.
/// The `DoubleRatchet` can only guarantee security of communication when instantiated with a
/// `CryptoProvider` with secure types and functions. The [specification] provides some sensible
/// [recommendations] and for example code using the `DoubleRatchet` see `tests/signal.rs`.
///
/// [specification]: https://signal.org/docs/specifications/doubleratchet/#external-functions
/// [recommendations]: https://signal.org/docs/specifications/doubleratchet/#recommended-cryptographic-algorithms
#[cfg(not(feature = "serde"))]
pub trait CryptoProvider {
    /// A public key for use in the Diffie-Hellman calculation.
    ///
    /// It is assumed that a `PublicKey` holds a valid key, so if any verification is required the
    /// constructor of this type would be a good place to do so.
    type PublicKey: AsRef<[u8]> + Debug + Clone + Eq + Hash + Send + Sync;

    /// A private/public key-pair for use in the Diffie-Hellman calculation.
    type KeyPair: KeyPair<PublicKey = Self::PublicKey>;

    /// The result of a Diffie-Hellman calculation.
    type SharedSecret;

    /// A `RootKey` is used in the outer Diffie-Hellman ratchet.
    type RootKey;

    /// A `ChainKey` is used in the inner symmetric ratchets.
    type ChainKey;

    /// A `MessageKey` is used to encrypt/decrypt messages.
    ///
    /// The implementation of this type could be a complex type: for example an implementation that
    /// works by the encrypt-then-MAC paradigm may require a tuple consisting of an encryption key
    /// and a MAC key.
    type MessageKey: Send + Sync;

    /// Perform the Diffie-Hellman operation.
    fn diffie_hellman(us: &Self::KeyPair, them: &Self::PublicKey) -> Self::SharedSecret;

    /// Derive a new root-key/chain-key pair from the old root-key and a fresh shared secret.
    fn kdf_rk(
        root_key: &Self::RootKey,
        shared_secret: &Self::SharedSecret,
    ) -> (Self::RootKey, Self::ChainKey);

    /// Derive a new chain-key/message-key pair from the old chain-key.
    fn kdf_ck(chain_key: &Self::ChainKey) -> (Self::ChainKey, Self::MessageKey);

    /// Authenticate-encrypt the plaintext and associated data.
    ///
    /// This method MUST authenticate `associated_data`, because it contains the header bytes.
    fn encrypt(key: &Self::MessageKey, plaintext: &[u8], associated_data: &[u8]) -> Vec<u8>;

    /// Verify-decrypt the ciphertext and associated data.
    fn decrypt(
        key: &Self::MessageKey,
        ciphertext: &[u8],
        associated_data: &[u8],
    ) -> Result<Vec<u8>, DecryptError>;
}
/// Provider of the required cryptographic types and functions.
///
/// The implementer of this trait provides the `DoubleRatchet` with the required external functions
/// as given in the [specification].
///
/// # Security considerations
///
/// The details of the `CryptoProvider` are critical for providing security of the communication.
/// The `DoubleRatchet` can only guarantee security of communication when instantiated with a
/// `CryptoProvider` with secure types and functions. The [specification] provides some sensible
/// [recommendations] and for example code using the `DoubleRatchet` see `tests/signal.rs`.
///
/// [specification]: https://signal.org/docs/specifications/doubleratchet/#external-functions
/// [recommendations]: https://signal.org/docs/specifications/doubleratchet/#recommended-cryptographic-algorithms
#[cfg(feature = "serde")]
pub trait CryptoProvider {
    /// A public key for use in the Diffie-Hellman calculation.
    ///
    /// It is assumed that a `PublicKey` holds a valid key, so if any verification is required the
    /// constructor of this type would be a good place to do so.
    type PublicKey: AsRef<[u8]> + Debug + Clone + Eq + Hash + Send + Sync;
    /// creates a `PublicKey`, necessary for recovering an instance
    /// from a persisted session state
    fn new_public_key(key: &[u8]) -> Result<Self::PublicKey, DRError>;

    /// A private/public key-pair for use in the Diffie-Hellman calculation.
    type KeyPair: KeyPair<PublicKey = Self::PublicKey>;

    /// The result of a Diffie-Hellman calculation.
    type SharedSecret;

    /// A `RootKey` is used in the outer Diffie-Hellman ratchet.
    type RootKey: AsRef<[u8]>;
    /// creates a `RootKey`, necessary for recovering an instance
    /// from a persisted session state
    fn new_root_key(key: &[u8]) -> Result<Self::RootKey, DRError>;

    /// A `ChainKey` is used in the inner symmetric ratchets.
    type ChainKey: AsRef<[u8]>;
    /// creates a `ChainKey`, necessary for recovering an instance
    /// from a persisted session state
    fn new_chain_key(key: &[u8]) -> Result<Self::ChainKey, DRError>;

    /// A `MessageKey` is used to encrypt/decrypt messages.
    ///
    /// The implementation of this type could be a complex type: for example an implementation that
    /// works by the encrypt-then-MAC paradigm may require a tuple consisting of an encryption key
    /// and a MAC key.
    type MessageKey: Clone + Debug + Send + Sync + Hash;

    /// Perform the Diffie-Hellman operation.
    fn diffie_hellman(us: &Self::KeyPair, them: &Self::PublicKey) -> Self::SharedSecret;

    /// Derive a new root-key/chain-key pair from the old root-key and a fresh shared secret.
    fn kdf_rk(
        root_key: &Self::RootKey,
        shared_secret: &Self::SharedSecret,
    ) -> (Self::RootKey, Self::ChainKey);

    /// Derive a new chain-key/message-key pair from the old chain-key.
    fn kdf_ck(chain_key: &Self::ChainKey) -> (Self::ChainKey, Self::MessageKey);

    /// Authenticate-encrypt the plaintext and associated data.
    ///
    /// This method MUST authenticate `associated_data`, because it contains the header bytes.
    fn encrypt(key: &Self::MessageKey, plaintext: &[u8], associated_data: &[u8]) -> Vec<u8>;

    /// Verify-decrypt the ciphertext and associated data.
    ///
    /// # Errors
    /// `DecryptError`
    fn decrypt(
        key: &Self::MessageKey,
        ciphertext: &[u8],
        associated_data: &[u8],
    ) -> Result<Vec<u8>, DecryptError>;
}

/// A private-/public-key pair
///
/// This trait is required for `CryptoProvider::KeyPair`
pub trait KeyPair {
    /// Type of the public half of the key pair
    ///
    /// This type should be equal to `CryptoProvider::PublicKey`
    type PublicKey;

    /// Generate a new random `KeyPair`
    fn new<R: CryptoRng + RngCore>(rng: &mut R) -> Self;

    /// Get a reference to the public half of the key pair
    fn public(&self) -> &Self::PublicKey;

    /// access the private key, this is required for persisting the session state
    #[cfg(feature = "serde")]
    fn private_bytes(&self) -> Vec<u8>;

    /// used for reinitialization using the persisted session state
    #[cfg(feature = "serde")]
    fn new_from_bytes(private: &[u8], public: &[u8]) -> Result<Self, DRError>
    where
        Self: Sized;
}

// Required information for updating the state after successful decryption
pub(crate) enum Diff<CP: CryptoProvider> {
    // Key was found amongst old key
    OldKey,

    // Key was part of the current receive chain
    CurrentChain(CP::ChainKey, Vec<CP::MessageKey>),

    // Key was part of the next receive chain
    NextChain(CP::RootKey, CP::ChainKey, Vec<CP::MessageKey>),
}


/// General Errors
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum DRError {
    /// Data is invalid or cannot be processed
    InvalidData,
    /// Key is invalid or cannot be processed
    InvalidKey,
}

#[cfg(feature = "std")]
impl Error for DRError {}

impl fmt::Display for DRError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use DRError::{InvalidData, InvalidKey};
        match self {
            InvalidData => write!(f, "Data is invalid or cannot be processed"),
            InvalidKey => write!(f, "Key is invalid or cannot be processed"),
        }
    }
}

/// Error that occurs on `try_ratchet_encrypt` before the state is initialized.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct EncryptUninit;

#[cfg(feature = "std")]
impl Error for EncryptUninit {}

impl fmt::Display for EncryptUninit {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Encrypt not yet initialized (you must receive a message first)"
        )
    }
}

/// Error that may occur during `ratchet_decrypt`
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum DecryptError {
    /// Could not verify-decrypt the ciphertext + associated data + header
    DecryptFailure,

    /// Could not find the message key required for decryption
    ///
    /// Note that this implementation is not always able to detect when an old `MessageKey` can't
    /// be found: a `DecryptFailure` may be triggered instead.
    MessageKeyNotFound,

    /// Header message counter is too large (either `n` or `pn`)
    SkipTooLarge,

    /// Storage of skipped message keys is full
    StorageFull,
}

#[cfg(feature = "std")]
impl Error for DecryptError {}

impl fmt::Display for DecryptError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use DecryptError::{DecryptFailure, MessageKeyNotFound, SkipTooLarge, StorageFull};
        match self {
            DecryptFailure => write!(f, "Error during verify-decrypting"),
            MessageKeyNotFound => {
                write!(f, "Could not find the message key required for decryption")
            }
            SkipTooLarge => write!(f, "Header message counter is too large"),
            StorageFull => write!(f, "Storage for skipped messages is full"),
        }
    }
}